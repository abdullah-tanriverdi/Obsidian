#Yazılım #ProgramlamaDilleri #Java 


![[JNI1.png]]

JNI (Java Native Interface), Java programlarının JVM üzerinde çalışmasına rağmen, ihtiyaç duyulduğunda C, C++, Assembly veya işletim sistemine özgü API’lerle doğrudan etkileşime girmesini sağlayan bir köprü (bridge) mekanizmasıdır.

Bu sayede:
- Performans kritik parçalar native dillerle yazılabilir,
- Var olan C/C++ kütüphaneleri yeniden kullanılabilir,
- Java’dan donanım veya işletim sistemi seviyesine erişim sağlanabilir.



**JNI Mimarisi**

```java
Java Kod (JVM)
    ↓  (JNI Çağrısı)
JNI API
    ↓
Native Kod (C/C++/ASM)
    ↓
İşletim Sistemi / Donanım

```
- **Java Tarafı**: `native` anahtar kelimesi ile bildirilen metodlar.
- **JNI API**: JVM ile native kod arasındaki köprü.
- **Native Tarafı**: C/C++ kodu, işletim sistemi çağrıları veya donanım erişimleri.


**JNI Bileşenleri**

1. **Java Sınıfı**  
    `native` metod bildirimi içerir ve `System.loadLibrary()` ile kütüphane yüklenir.

2. **Header (.h)**  
    `javac -h` komutu ile oluşturulur. Bu, C/C++ tarafında kullanılacak fonksiyon imzalarını içerir.

3. **C/C++ Kod (.c / .cpp)**  
    Native metodların gerçek implementasyonu yapılır.

4. **Paylaşımlı Kütüphane (.dll / .so / .dylib)**  
    Derlenen native kod kütüphane hâlinde JVM tarafından yüklenir.


**JNI ile Adım Adım Çalışma**

- **Java Tarafı - Native Metod Tanımı**
```java
public class MyJNI {
    // Native metod bildirimi
    public native void helloFromC();

    static {
        // Kütüphaneyi yükle
        System.loadLibrary("myjni");
    }

    public static void main(String[] args) {
        new MyJNI().helloFromC();
    }
}

```

- **Header Dosyası Oluşturma**
Terminal
```bash
javac MyJNI.java
javac -h . MyJNI.java

```
Bu işlem MyJNI.h dosyasını üretir.

- **C/C++ Tarafı - Metodu Gerçekleştirme**
```c
#include <jni.h>
#include <stdio.h>
#include "MyJNI.h"

JNIEXPORT void JNICALL Java_MyJNI_helloFromC(JNIEnv *env, jobject obj) {
    printf("C tarafindan merhaba!\n");
}

```

- **Paylaşımlı Kütüphane Derleme**
Linux/Mac
```bash
gcc -I"$JAVA_HOME/include" -I"$JAVA_HOME/include/linux" -shared -fpic MyJNI.c -o libmyjni.so

```

Windows
```bash
gcc -I"%JAVA_HOME%\include" -I"%JAVA_HOME%\include\win32" -shared -o myjni.dll MyJNI.c

```

- **Çalıştırma**
```bash
java MyJNI

```
Çıktı:
```mathematica  
C tarafindan merhaba!

```

**Dikkat Edilmesi Gerekenler**

|Konu|Açıklama|
|---|---|
|**Bellek Yönetimi**|Java GC, native kodda ayırdığınız belleği görmez.|
|**Platform Bağımlılığı**|Native kod her platform için ayrı derlenmelidir (`.so`, `.dll`, `.dylib`).|
|**Hata Yönetimi**|Native kodda oluşan bir segmentation fault JVM’i tamamen çökertir.|
|**Güvenlik**|JNI ile dosya sistemi, ağ ve donanım seviyesine erişim mümkündür → güvenlik açıklarına dikkat edilmeli.|


**JNI Kullanım Seneryoları**

|Senaryo|Örnek|
|---|---|
|**Performans**|Sayısal hesaplama kütüphanesini C ile yazıp Java’dan çağırmak|
|**Mevcut Kütüphane**|OpenCV (C++), TensorFlow (C++) kütüphanelerini Java’dan kullanmak|
|**Donanım Erişimi**|USB cihaz sürücüsü, sensör, gömülü cihaz bağlantısı|
|**Platform Özelliği**|Windows API çağrıları, Linux Kernel modülleri|


> [!NOTE] ÖZET
> JNI, Java’nın donanım ve sistem sınırlarını aşmasını sağlayan güçlü ama tehlikeli bir araçtır.
>- Avantajı: Performans ve esneklik.
>- Dezavantajı: Karmaşıklık, güvenlik ve taşınabilirlik kaybı.


<iframe
  width="560" height="315"
  src="https://www.youtube.com/embed/N7ViTwn682k"
  title="YouTube video player"
  frameborder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  allowfullscreen>
</iframe>


> [!info] İPUCU
> [[001 -History Of Java]]
> [[002 -JVM]]
> [[008 -Assembly]]
> [[009 -API]]
> [[003 -Garbage Collection]]

***

***Abdullah TANRIVERDİ***